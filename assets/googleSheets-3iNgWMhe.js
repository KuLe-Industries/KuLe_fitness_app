import{g as n,s as p,_ as c,a as d,b as g,c as w,v}from"./index-DdalX-Od.js";const u=Object.freeze(Object.defineProperty({__proto__:null,v4:v},Symbol.toStringTag,{value:"Module"}));class y{async getCurrent(){try{const t=await n.getRange("Users","A2:D1000");if(!t.values||t.values.length===0)return null;const o=t.values[t.values.length-1];return{id:o[0],displayName:o[1],preferences:JSON.parse(o[2]),lockedExerciseDefaults:{}}}catch(t){return console.error("Failed to get user from Google Sheets:",t),null}}async save(t){try{await p(t)}catch(o){throw console.error("Failed to save user to Google Sheets:",o),o}}async clear(){}}class h{async getAll(){try{const t=await n.getRange("Exercises","A2:G1000");return t.values?t.values.map(o=>{const e=o;return{id:e[0],name:e[1],muscleGroups:e[2]?e[2].split(", ").filter(s=>s):[],equipment:e[3]?e[3].split(", ").filter(s=>s):[],tags:e[4]?e[4].split(", ").filter(s=>s):[],instructions:e[5]||void 0}}):[]}catch(t){return console.error("Failed to get exercises from Google Sheets:",t),[]}}async getById(t){return(await this.getAll()).find(e=>e.id===t)||null}async create(t){const{v4:o}=await c(async()=>{const{v4:s}=await Promise.resolve().then(()=>u);return{v4:s}},void 0),e={...t,id:o()};return await d(e),e}async update(t,o){const e=await this.getById(t);if(!e)throw new Error(`Exercise ${t} not found`);const s={...e,...o};return await d(s),s}async delete(t){console.warn("Delete operation not fully implemented for Google Sheets")}async search(t){const o=await this.getAll(),e=t.toLowerCase();return o.filter(s=>{var r,l;return s.name.toLowerCase().includes(e)||s.muscleGroups.some(a=>a.toLowerCase().includes(e))||((r=s.equipment)==null?void 0:r.some(a=>a.toLowerCase().includes(e)))||((l=s.tags)==null?void 0:l.some(a=>a.toLowerCase().includes(e)))})}async filterByMuscleGroup(t){return(await this.getAll()).filter(e=>e.muscleGroups.some(s=>s.toLowerCase()===t.toLowerCase()))}async filterByEquipment(t){return(await this.getAll()).filter(e=>{var s;return(s=e.equipment)==null?void 0:s.some(r=>r.toLowerCase()===t.toLowerCase())})}}class f{async getAll(){try{const t=await n.getRange("Plans","A2:H1000");return t.values?t.values.map(o=>{const e=o;return{id:e[0],name:e[1],description:e[2]||void 0,blocks:JSON.parse(e[3]),schedule:e[4]?JSON.parse(e[4]):void 0,createdAt:e[5],updatedAt:e[6],isFavorite:e[7]==="TRUE"}}):[]}catch(t){return console.error("Failed to get plans from Google Sheets:",t),[]}}async getById(t){return(await this.getAll()).find(e=>e.id===t)||null}async create(t){const{v4:o}=await c(async()=>{const{v4:r}=await Promise.resolve().then(()=>u);return{v4:r}},void 0),e=new Date().toISOString(),s={...t,id:o(),createdAt:e,updatedAt:e,isFavorite:t.isFavorite??!1};return await g({...s,isFavorite:s.isFavorite??!1}),s}async update(t,o){const e=await this.getById(t);if(!e)throw new Error(`Plan ${t} not found`);const s={...e,...o,updatedAt:new Date().toISOString()};return await g({...s,isFavorite:s.isFavorite??!1}),s}async delete(t){console.warn("Delete operation not fully implemented for Google Sheets")}async duplicate(t,o){const e=await this.getById(t);if(!e)throw new Error(`Plan ${t} not found`);const{id:s,createdAt:r,updatedAt:l,...a}=e;return this.create({...a,name:o,isFavorite:!1})}async getFavorites(){return(await this.getAll()).filter(o=>o.isFavorite)}}class S{async getAll(t){try{const o=await n.getRange("Sessions","A2:H1000");return o.values?o.values.map(s=>{const r=s;return{id:r[0],userId:r[1],planId:r[2]||void 0,startedAt:r[3],endedAt:r[4]||void 0,notes:r[5]||void 0,items:JSON.parse(r[6])}}).filter(s=>s.userId===t):[]}catch(o){return console.error("Failed to get sessions from Google Sheets:",o),[]}}async getById(t){try{const o=await n.getRange("Sessions","A2:H1000");if(!o.values)return null;const e=o.values.find(r=>r[0]===t);if(!e)return null;const s=e;return{id:s[0],userId:s[1],planId:s[2]||void 0,startedAt:s[3],endedAt:s[4]||void 0,notes:s[5]||void 0,items:JSON.parse(s[6])}}catch(o){return console.error("Failed to get session from Google Sheets:",o),null}}async create(t){const{v4:o}=await c(async()=>{const{v4:s}=await Promise.resolve().then(()=>u);return{v4:s}},void 0),e={...t,id:o()};return await w(e),e}async update(t,o){const e=await this.getById(t);if(!e)throw new Error(`Session ${t} not found`);const s={...e,...o};return await w(s),s}async delete(t){console.warn("Delete operation not fully implemented for Google Sheets")}async getByPlan(t){return(await this.getAll("")).filter(e=>e.planId===t)}async getByDateRange(t,o,e){return(await this.getAll(t)).filter(r=>r.startedAt>=o&&r.startedAt<=e)}}const A=new y,_=new h,R=new f,x=new S;export{_ as googleSheetsExerciseRepo,R as googleSheetsPlanRepo,x as googleSheetsSessionRepo,A as googleSheetsUserRepo};
